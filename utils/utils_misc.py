import os
import string
from os import path as osp
from typing import Union


def get_model_prefix(args):
    """
    Returns the model prefix of a model. By default, we use GPT-3.5.

    Args:
        args: An argparse object containing model configuration.

    Returns:
        str: The model prefix.
    """

    if args.model != "gpt35":
        model_prefix = f"{args.model}_"
    else:
        model_prefix = ""

    return model_prefix

def capitalize_and_strip_punctuation(answer: Union[str, None]):
    if isinstance(answer, str):
        answer = answer.strip(
            string.punctuation + "，。？！।॥").capitalize()

    return answer


def map_prediction_to_binary_MedAlpaca(x, language: str = "English", return_string=True, return_unknown=False):
    r"""Map the predictions of MedAlpaca to binary (Yes/No/Unknown).

    Since the answers generated by MedAlpaca is significantly different from the answers generated by GPT-3.5,
    we need to map the answers using a different format.

    :param x:
    :param language:
    :param return_string:
    :param return_unknown:
    :return:
    """

    import const

    if isinstance(x, str):

        x = x.split("### Input")[-1].split("Question")[-1].split("Response")[-1]

    # Both "Yes" and "No" are in the answer
    if isinstance(x, str) and (any([segment in x for segment in const.ANSWER_MAP["No"][language]]) and any([segment in x
        for segment in const.ANSWER_MAP["Yes"][language]])):
        print(x)
        return "Unknown" if return_string else -1


    # Only "Yes" is in the answer
    elif isinstance(x, str) and any([segment in x for segment in const.ANSWER_MAP["Yes"][language]]):
        return "Yes" if return_string else 1

    # Only "No" is in the answer
    elif isinstance(x, str) and any([segment in x for segment in const.ANSWER_MAP["No"][language]]):
        return "No" if return_string else 1

    elif isinstance(x, str) and any(
            [x.capitalize().startswith(prefix) for prefix in
             const.ANSWER_MAP["Unknown"][language]]):
        return "Unknown" if return_string else -1

    else:
        if not return_string:
            return -1


        elif return_unknown:
            return "Unknown"

        else:
            return x

def map_prediction_to_binary(x, language: str = "English", return_string=True, return_unknown=False):
    r"""Map the predictions of GPT-3.5/4 to binary (Yes/No/Unknown).

   GPT models tend to generate more than we instruct them to do. So we need to map the answers using a different format.

   :param x:
   :param language:
   :param return_string:
   :param return_unknown:
   :return:
   """

    import const

    if isinstance(x, str) and (any([x.capitalize().startswith(prefix) for prefix in const.ANSWER_MAP["No"][language]]) or ("no" in x.lower() and "yes" not in x.lower())):
        return "No" if return_string else 0

    elif isinstance(x, str) and (any([x.capitalize().startswith(prefix) for prefix in const.ANSWER_MAP["Yes"][language]] or ("yes" in x.lower() and "no" not in x.lower()))):
        return "Yes" if return_string else 1

    elif isinstance(x, str) and any(
            [x.capitalize().startswith(prefix) for prefix in
             const.ANSWER_MAP["Unknown"][language]]):
        return "Unknown" if return_string else -1

    else:
        if not return_string:
            return -1


        elif return_unknown:
            return "Unknown"

        else:
            return x


def capitalize_dataset_name(dataset_name: str):
    return dataset_name[:-2].capitalize() + "QA"


def check_cwd():

    print(os.getcwd())
    basename = osp.basename(osp.normpath(os.getcwd()))
    assert basename.lower() in [
        "xlingeval"], "Please run this file from the repository root (XLingEval/)"
